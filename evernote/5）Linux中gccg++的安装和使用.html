<html>
<head>
  <title>5）Linux中gcc/g++的安装和使用</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1423"/>
<h1>5）Linux中gcc/g++的安装和使用</h1>

<div>
<span><div><span style="font-size: 16pt; color: rgb(255, 0, 0);">5）Linux中gcc/g++的安装和使用</span></div><div>详细地址：<a href="https://blog.csdn.net/mou_it/article/details/79842193">https://blog.csdn.net/mou_it/article/details/79842193</a></div><div><br/></div><div>1、GCC、gcc、g++的区别：</div><div>（1）三者比较</div><div><span style="color: rgb(255, 70, 53);">      GCC : GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</span></div><div><span style="color: rgb(255, 70, 53);">      gcc是GCC中的GUN C Compiler（C 编译器）</span></div><div><span style="color: rgb(255, 70, 53);">      g++是GCC中的GUN C++ Compiler（C++编译器）</span></div><div>    一个有趣的事实就是，就本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已，比如，用gcc编译一个c文件的话，会有以下几个步骤：</div><div>    Step1：调用预处理器</div><div>    Step2：调用编译器</div><div>    Step3：调用汇编器</div><div>    Step4：调用连接</div><div>    由于编译器是可以更换的，所以gcc不仅仅可以编译C文件，更准确的说法是：gcc调用了C编译器，而g++调用了C++编译器。</div><div><br/></div><div>（2）gcc和g++的主要区别</div><div>    1）对于 *.c和*.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）；</div><div>    2） 对于 *.c和*.cpp文件，g++则统一当做cpp文件编译；</div><div>    3）使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL；</div><div>    4）gcc在编译C文件时，可使用的预定义宏是比较少的；</div><div>    5）gcc在编译cpp文件时或者g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：</div><div>    #define __GXX_WEAK__ 1</div><div>    #define __cplusplus 1</div><div>    #define __DEPRECATED 1</div><div>    #define __GNUG__ 4</div><div>    #define __EXCEPTIONS 1</div><div>    #define __private_extern__ extern</div><div>    6）在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价，它们的区别不仅仅是这个，主要参数：</div><div>    -g - turn on debugging (so GDB gives morefriendly output)</div><div>    -Wall - turns on most warnings</div><div>    -O or -O2 - turn on optimizations</div><div>    -o - name of the output file</div><div>    -c - output an object file (.o)</div><div>    -I - specify an includedirectory</div><div>    -L - specify a libdirectory</div><div>    -l - link with librarylib.a</div><div><br/></div><div>2、Linux(这里为Ubuntu系统)中安装gcc和g++</div><div><span style="font-weight: bold; color: rgb(255, 70, 53);">   1）先安装gcc：   sudo apt-get install build-essential</span></div><div><span style="font-weight: bold; color: rgb(255, 70, 53);">   2）查看gcc版本：       gcc --version</span></div><div><span style="font-weight: bold; color: rgb(255, 70, 53);">   3）然后安装统一版本的g++：  sudo apt-get install g++-x.x</span></div><div><span style="font-weight: bold; color: rgb(255, 70, 53);">   4）查看g++版本：g++ --version</span></div><div>   5）查看gcc默认的include路径：`gcc -print-prog-name=cc1plus` -v</div><div>     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include</div><div>     /usr/local/include</div><div>     /usr/include</div><div>   6）查看g++默认的include路径：`g++ -print-prog-name=cc1plus` -v</div><div>     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include</div><div>     /usr/local/include</div><div>     /usr/include</div><div>   7）查看gcc默认lib路径：gcc --print-searrch-dir</div><div>   8）查看g++默认lib路径：g++ --print-search-dir</div><div><br/></div><div>3、头文件和库文件默认搜索路径</div><div><span>    </span><font style="color: rgb(255, 0, 0);"><b><span>    </span>头文件中有函数的申明，库文件实现函数的定义。库文件通过头文件向外导出接口。用户通过头文件找到库文件中函数实现的代码从而把这段代码链接到用户程序中去。</b></font><br/></div><div>    1）头文件搜索路径：</div><div>    先搜索 -I 指定的目录（这里的 -I 是大写的 i）；然后寻找环境变量指定目录：<b>C_INCLUDE_PATH，CPLUS_INCLUDE_PATH，OBJC_INCLUDE_PATH</b>可以通过设置这些环境变量来添加系统include的路径：</div><div>    export C_INCLUDE_PATH=XXXX:$C_INCLUDE_PATH         # C    </div><div>    export CPLUS_INCLUDE_PATH=XXX:$CPLUS_INCLUDE_PATH  # CPP</div><div>    以上修改可以直接命令输入（一次性），可以在/etc/profile中完成（对所有用户生效），也可以在用户home目录下.bashrc或者.bash_profile中添加（针对某个用户生效）。</div><div><br/></div><div>    最后搜索gcc的内定目录。</div><div>     /usr/lib/gcc/x86_64-redhat-linux/4.8.5/include</div><div>     /usr/local/include</div><div>     /usr/include</div><div>    2）库文件搜索路径</div><div>    编译时,gcc会去找-L；</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">    再找gcc的环境变量LIBRARY_PATH：</span><span style="color: rgb(107, 231, 72); font-weight: bold;">LIBRARY_PATH和LD_LIBRARY_PATH</span><span style="color: rgb(255, 0, 0); font-weight: bold;">是Linux下的两个环境变量，LIBRARY_PATH环境变量用于在程序编译期间查找动态链接库时指定查找共享库的路径，而LD_LIBRARY_PATH环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径；</span></div><div>    再找内定目录：/lib  :  /usr/lib  :  /usr/local/lib，这是当初compile gcc时写在程序内的。</div><div>    运行时：Linux动态库的默认搜索路径时 /lib 和 /usr/lib，动态库别创建后，都复制到这两个目录中。在Linux中，动态库的搜索路径除了默认的搜索路径外，还可以通过以下三种方法来指定：</div><div><br/></div><div>    方法一：在配置文件/etc/ld.so.conf中指定动态库搜索路径。但是每次编辑完该文件后，都必须运行命令ldconfig以达到刷新 /etc/ld.so.cache的效果，使修改后的配置生效；</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">    方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径；</span></div><div>    方法三：在编译目标代码时指定该程序的动态库搜索路径。</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">            export LD_LIBRARY_PATH=XXX:$LD_LIBRARY_PATH   # 动态链接库搜索路径</span></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">            export LIBRARY_PATH=XXX:$LIBRARY_PATH         # 静态链接库搜索路径</span></div><div>            以上修改可以直接命令输入（一次性），可以在/etc/profile中完成（对所有用户生效），也可以在用户home目录下.bashrc或者.bash_profile中添加（针对某个用户生效）。</div><div><br/></div><div>4、gcc所遵循的部分约定规则：</div><div>  .c为后缀的文件，C语言源代码文件；</div><div>  .a为后缀的文件，是由目标文件构成的档案库文件；</div><div>  .C或.cc或.cxx为后缀的文件，是C++源代码文件；</div><div>  .h为后缀的文件，是程序所包含的头文件；</div><div>  .i为后缀的文件，是已经预处理过的C源代码文件；</div><div>  .ii为后缀的文件，是已经预处理过的C++源代码文件；</div><div>  .m为后缀的文件，是Objective-C源代码文件；</div><div>  .o为后缀的文件，是编译后的目标文件，相当于window中.obj文件；</div><div>  .s为后缀的文件，是汇编语言源代码文件；</div><div>  .S为后缀的文件，是经过预编译的汇编语言源代码文件。</div><div><br/></div></span>
</div></body></html> 