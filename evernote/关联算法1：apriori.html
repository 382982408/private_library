<html>
<head>
  <title>关联算法1：apriori</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600753 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="467"/>
<h1>关联算法1：apriori</h1>

<div>
<span><div><span style="font-size: 16pt;">关联算法1：apriori</span></div><div><br/></div><div>#!/usr/bin/env python</div><div><br/></div><div>&quot;&quot;&quot;</div><div>问题1：为什么要程序中一定要用frozenset这种数据类型？</div><div>    python中的类型分可以分为两类，可变类型和不可变类型:</div><div>    可变类型：dict、tuple、list、set,不可变类型：int、long、float、complex、string、bool、freqSet.</div><div>    其中可变类型不能作为字典的key，因为它们没有__hash__()方法。</div><div>&quot;&quot;&quot;</div><div><br/></div><div>import sys,re,os,pprint,json</div><div>from numpy import *</div><div>def loadDataSet():</div><div>    &quot;&quot;&quot;</div><div>    function:构造原始数据</div><div>    &quot;&quot;&quot;</div><div>    return [[1, 3, 4], [2, 3, 5], [1, 2, 3, 5], [2, 5]]</div><div>def createC1(dataSet):</div><div>    &quot;&quot;&quot;</div><div>    function:求所有数据中所有元素的不可变集合，frozenset一种不可变的集合，set为可变集合</div><div>    &quot;&quot;&quot;</div><div>    C1 = []</div><div>    for transaction in dataSet:</div><div>        for item in transaction:</div><div>            if not [item] in C1:</div><div>                C1.append([item])</div><div>    C1.sort()</div><div>    return list(map(frozenset, C1))  # set可变集合，不能用作哈希的key值，frozenset一种不可变的集合，可作为哈希的key值</div><div>def scanD(D, Ck, minSupport):</div><div>    &quot;&quot;&quot;</div><div>    function:过滤掉不符合支持度的集合,返回 频繁项集列表retList 所有元素的支持度字典</div><div>    &quot;&quot;&quot;</div><div>    ssCnt = {}</div><div>    for tid in D:</div><div>        for can in Ck:</div><div>            if can.issubset(tid):   # 判断can是否是tid的《子集》 （这里使用子集的方式来判断两者的关系）</div><div>                if can not in ssCnt:    # 统计该值在整个记录中满足子集的次数（以字典的形式记录，frozenset为键）</div><div>                    ssCnt[can] = 1</div><div>                else:</div><div>                    ssCnt[can] += 1</div><div>    numItems = float(len(D))</div><div>    retList = []        # 重新记录满足条件的数据值（即支持度大于阈值的数据）</div><div>    supportData = {}    # 每个数据值的支持度</div><div>    for key in ssCnt:</div><div>        support = ssCnt[key] / numItems</div><div>        if support &gt;= minSupport:</div><div>            retList.append(key)</div><div>            supportData[key] = support</div><div>    return retList, supportData # 排除不符合支持度元素后的元素 每个元素支持度</div><div>def aprioriGen(Lk, k):</div><div>    &quot;&quot;&quot;</div><div>    function:#根据上一次的频繁项集结果生产新的 更多元素的频繁项集</div><div>    &quot;&quot;&quot;</div><div>    retList = []</div><div>    lenLk = len(Lk)</div><div>    for i in range(lenLk): # 两层循环比较Lk中的每个元素与其它元素</div><div>        for j in range(i+1, lenLk):</div><div>            # 这里说明一下：该函数每次比较两个list的前k-2个元素，如果相同则求并集得到k个元素的集合</div><div>            L1 = list(Lk[i])[:k-2]  # 将集合转为list后取值</div><div>            L2 = list(Lk[j])[:k-2]</div><div>            L1.sort()</div><div>            L2.sort()</div><div>            if L1==L2:</div><div>                #pass</div><div>                retList.append(Lk[i] | Lk[j]) # 求并集</div><div>    return retList  # 返回频繁项集列表Ck</div><div><br/></div><div>def apriori(dataSet,minSupport):</div><div>    &quot;&quot;&quot;</div><div>    function:apriory算法主程序，封装所有步骤的函数,返回所有满足大于阈值的组合，集合支持度列表</div><div>    &quot;&quot;&quot;</div><div>    D = list(map(set, dataSet)) # 转换列表记录为字典  [{1, 3, 4}, {2, 3, 5}, {1, 2, 3, 5}, {2, 5}]</div><div>    C1 = createC1(dataSet)      # 将每个元素转会为frozenset字典    [frozenset({1}), frozenset({2}), frozenset({3}), frozenset({4}), frozenset({5})]</div><div><br/></div><div>    L1, supportData = scanD(D, C1, minSupport)  # 过滤数据</div><div>    L = [L1]    #一个元素组成的频繁项集</div><div>    k= 2</div><div>    result_L=[] #只报道两个元素以上的项集</div><div>    result_supportData={}   #只存储两个元素以上的项集的结果</div><div>    while (len(L[k-2]) &gt; 0):    # 若由（k-1）个元素组成频繁项集仍有满足支持度的集合则继续做关联分析</div><div>        Ck = aprioriGen(L[k-2], k)  # Ck候选频繁项集</div><div>        Lk, supK = scanD(D, Ck, minSupport) # Lk频繁项集</div><div>        supportData.update(supK)    # 更新字典（把新出现的集合:支持度加入到supportData中）</div><div>        L.append(Lk)</div><div>        result_supportData.update(supK)</div><div>        result_L.append(Lk)</div><div>        k += 1  # 每次新组合的元素都只增加了一个</div><div>    return result_L, result_supportData</div><div><br/></div><div><br/></div><div>def generateRules(L, supportData, minConf):  # supportData 是一个字典</div><div>    &quot;&quot;&quot;</div><div>    function:获取关联规则的封装函数</div><div>    &quot;&quot;&quot;</div><div>    print (L)</div><div>    bigRuleList = []</div><div>    for i in range(len(L)):  # 从为2个元素的集合开始</div><div>        if len(L[i])==0:continue</div><div>        for freqSet in L[i]:</div><div>            # 只包含单个元素的集合列表</div><div>            H1 = [frozenset([item]) for item in freqSet]    # frozenset({2, 3}) 转换为 [frozenset({2}), frozenset({3})]</div><div>            print(H1)</div><div>            # 如果集合元素大于2个，则需要处理才能获得规则</div><div>            if (i &gt; 1):</div><div>                rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf) # 集合元素 集合拆分后的列表 。。。</div><div>            else:</div><div>                print (&quot;here&quot;)</div><div>                print (freqSet)</div><div>                print(H1)</div><div>                calcConf(freqSet, H1, supportData, bigRuleList, minConf)</div><div>    sys.exit()</div><div>    return bigRuleList</div><div># 对规则进行评估 获得满足最小可信度的关联规则</div><div>def calcConf(freqSet, H, supportData, brl, minConf):</div><div>    prunedH = []  # 创建一个新的列表去返回</div><div>    for conseq in H:</div><div>        conf = supportData[freqSet]/supportData[freqSet-conseq]  # 计算置信度</div><div>        if conf &gt;= minConf:</div><div>            #print(freqSet-conseq,'--&gt;',conseq,'conf:',conf)</div><div>            brl.append((freqSet-conseq, conseq, conf))</div><div>            prunedH.append(conseq)</div><div>    return prunedH</div><div># 生成候选规则集合</div><div>def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7):</div><div>    m = len(H[0])</div><div>    if (len(freqSet) &gt; (m + 1)): # 尝试进一步合并</div><div>        Hmp1 = aprioriGen(H, m+1) # 将单个集合元素两两合并</div><div>        Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf)</div><div>        if (len(Hmp1) &gt; 1):    #need at least two sets to merge</div><div>            rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf)</div><div><br/></div><div>if __name__ == '__main__':</div><div>    dataSet = loadDataSet()</div><div>    minSupport= 0.5    #最小支持度</div><div>    L,suppData = apriori(dataSet,minSupport)</div><div>    pprint.pprint(suppData)</div><div>    #print(json.dumps(suppData,indent=2))    ###keys must be str, int, float, bool or None, not frozenset</div><div>    </div><div>    minConf=0.7</div><div>    rules = generateRules(L,suppData,minConf)</div><div>    pprint.pprint(rules)</div><div><br/></div></span>
</div></body></html> 